{"version":3,"sources":["webpack:///./node_modules/@capacitor/local-notifications/dist/esm/web.js"],"names":["LocalNotificationsWeb","super","arguments","this","pending","hasNotificationSupport","window","Notification","requestPermission","permission","e","name","unimplemented","options","unavailable","notification","notifications","sendNotification","map","id","filter","find","n","display","checkPermissions","value","transformNotificationPermission","_a","toRemove","now","Date","getTime","schedule","at","buildNotification","push","diff","setTimeout","sendPending","localNotification","title","body","addEventListener","onClick","bind","onShow","data","actionId","notifyListeners"],"mappings":"kHAAA,6EACO,MAAMA,UAA8B,OACvC,cACIC,SAASC,WACTC,KAAKC,QAAU,GACfD,KAAKE,uBAAyB,KAC1B,KAAM,iBAAkBC,UAAYC,aAAaC,kBAC7C,OAAO,EAEX,GAAgC,YAA5BD,aAAaE,WAGb,IACI,IAAIF,aAAa,IAErB,MAAOG,GACH,GAAc,aAAVA,EAAEC,KACF,OAAO,EAInB,OAAO,GAGf,sBACI,MAAMR,KAAKS,cAAc,2BAE7B,sBACI,MAAMT,KAAKS,cAAc,2BAE7B,qBACI,MAAMT,KAAKS,cAAc,2BAE7B,eAAeC,GACX,IAAKV,KAAKE,yBACN,MAAMF,KAAKW,YAAY,gDAE3B,IAAK,MAAMC,KAAgBF,EAAQG,cAC/Bb,KAAKc,iBAAiBF,GAE1B,MAAO,CACHC,cAAeH,EAAQG,cAAcE,IAAIH,IAAgB,CACrDI,GAAIJ,EAAaI,OAI7B,mBACI,MAAO,CACHH,cAAeb,KAAKC,SAG5B,4BACI,MAAMD,KAAKS,cAAc,2BAE7B,aAAaR,GACTD,KAAKC,QAAUD,KAAKC,QAAQgB,OAAOL,IAAiBX,EAAQY,cAAcK,KAAKC,GAAKA,EAAEH,KAAOJ,EAAaI,KAE9G,mBACI,MAAM,QAAEI,SAAkBpB,KAAKqB,mBAC/B,MAAO,CACHC,MAAmB,YAAZF,GAGf,2BACI,IAAKpB,KAAKE,yBACN,MAAMF,KAAKW,YAAY,gDAE3B,MAAMS,EAAUpB,KAAKuB,sCAAsCnB,aAAaC,qBACxE,MAAO,CAAEe,WAEb,yBACI,IAAKpB,KAAKE,yBACN,MAAMF,KAAKW,YAAY,gDAE3B,MAAMS,EAAUpB,KAAKuB,gCAAgCnB,aAAaE,YAClE,MAAO,CAAEc,WAEb,gCAAgCd,GAC5B,OAAQA,GACJ,IAAK,UACD,MAAO,UACX,IAAK,SACD,MAAO,SACX,QACI,MAAO,UAGnB,cACI,IAAIkB,EACJ,MAAMC,EAAW,GACXC,GAAM,IAAIC,MAAOC,UACvB,IAAK,MAAMhB,KAAgBZ,KAAKC,SACU,QAAhCuB,EAAKZ,EAAaiB,gBAA6B,IAAPL,OAAgB,EAASA,EAAGM,KACtElB,EAAaiB,SAASC,GAAGF,WAAaF,IACtC1B,KAAK+B,kBAAkBnB,GACvBa,EAASO,KAAKpB,IAGtBZ,KAAKC,QAAUD,KAAKC,QAAQgB,OAAOL,IAAiBa,EAASP,KAAKC,GAAKA,IAAMP,IAEjF,iBAAiBA,GACb,IAAIY,EACJ,GAAqC,QAAhCA,EAAKZ,EAAaiB,gBAA6B,IAAPL,OAAgB,EAASA,EAAGM,GAAI,CACzE,MAAMG,EAAOrB,EAAaiB,SAASC,GAAGF,WAAY,IAAID,MAAOC,UAK7D,OAJA5B,KAAKC,QAAQ+B,KAAKpB,QAClBsB,WAAW,KACPlC,KAAKmC,eACNF,GAGPjC,KAAK+B,kBAAkBnB,GAE3B,kBAAkBA,GACd,MAAMwB,EAAoB,IAAIhC,aAAaQ,EAAayB,MAAO,CAC3DC,KAAM1B,EAAa0B,OAIvB,OAFAF,EAAkBG,iBAAiB,QAASvC,KAAKwC,QAAQC,KAAKzC,KAAMY,IAAe,GACnFwB,EAAkBG,iBAAiB,OAAQvC,KAAK0C,OAAOD,KAAKzC,KAAMY,IAAe,GAC1EwB,EAEX,QAAQxB,GACJ,MAAM+B,EAAO,CACTC,SAAU,MACVhC,gBAEJZ,KAAK6C,gBAAgB,mCAAoCF,GAE7D,OAAO/B,GACHZ,KAAK6C,gBAAgB,4BAA6BjC","file":"js/chunk-2d0bd7bb.9f8baf5f.js","sourcesContent":["import { WebPlugin } from '@capacitor/core';\nexport class LocalNotificationsWeb extends WebPlugin {\n    constructor() {\n        super(...arguments);\n        this.pending = [];\n        this.hasNotificationSupport = () => {\n            if (!('Notification' in window) || !Notification.requestPermission) {\n                return false;\n            }\n            if (Notification.permission !== 'granted') {\n                // don't test for `new Notification` if permission has already been granted\n                // otherwise this sends a real notification on supported browsers\n                try {\n                    new Notification('');\n                }\n                catch (e) {\n                    if (e.name == 'TypeError') {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n    }\n    async createChannel() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async deleteChannel() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async listChannels() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async schedule(options) {\n        if (!this.hasNotificationSupport()) {\n            throw this.unavailable('Notifications not supported in this browser.');\n        }\n        for (const notification of options.notifications) {\n            this.sendNotification(notification);\n        }\n        return {\n            notifications: options.notifications.map(notification => ({\n                id: notification.id,\n            })),\n        };\n    }\n    async getPending() {\n        return {\n            notifications: this.pending,\n        };\n    }\n    async registerActionTypes() {\n        throw this.unimplemented('Not implemented on web.');\n    }\n    async cancel(pending) {\n        this.pending = this.pending.filter(notification => !pending.notifications.find(n => n.id === notification.id));\n    }\n    async areEnabled() {\n        const { display } = await this.checkPermissions();\n        return {\n            value: display === 'granted',\n        };\n    }\n    async requestPermissions() {\n        if (!this.hasNotificationSupport()) {\n            throw this.unavailable('Notifications not supported in this browser.');\n        }\n        const display = this.transformNotificationPermission(await Notification.requestPermission());\n        return { display };\n    }\n    async checkPermissions() {\n        if (!this.hasNotificationSupport()) {\n            throw this.unavailable('Notifications not supported in this browser.');\n        }\n        const display = this.transformNotificationPermission(Notification.permission);\n        return { display };\n    }\n    transformNotificationPermission(permission) {\n        switch (permission) {\n            case 'granted':\n                return 'granted';\n            case 'denied':\n                return 'denied';\n            default:\n                return 'prompt';\n        }\n    }\n    sendPending() {\n        var _a;\n        const toRemove = [];\n        const now = new Date().getTime();\n        for (const notification of this.pending) {\n            if (((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) &&\n                notification.schedule.at.getTime() <= now) {\n                this.buildNotification(notification);\n                toRemove.push(notification);\n            }\n        }\n        this.pending = this.pending.filter(notification => !toRemove.find(n => n === notification));\n    }\n    sendNotification(notification) {\n        var _a;\n        if ((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) {\n            const diff = notification.schedule.at.getTime() - new Date().getTime();\n            this.pending.push(notification);\n            setTimeout(() => {\n                this.sendPending();\n            }, diff);\n            return;\n        }\n        this.buildNotification(notification);\n    }\n    buildNotification(notification) {\n        const localNotification = new Notification(notification.title, {\n            body: notification.body,\n        });\n        localNotification.addEventListener('click', this.onClick.bind(this, notification), false);\n        localNotification.addEventListener('show', this.onShow.bind(this, notification), false);\n        return localNotification;\n    }\n    onClick(notification) {\n        const data = {\n            actionId: 'tap',\n            notification,\n        };\n        this.notifyListeners('localNotificationActionPerformed', data);\n    }\n    onShow(notification) {\n        this.notifyListeners('localNotificationReceived', notification);\n    }\n}\n//# sourceMappingURL=web.js.map"],"sourceRoot":""}